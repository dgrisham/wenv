#!/usr/bin/zsh

wenv_setup() {
    WENV_DIR="$SRC/wenv"
    WENV_DEPS=('x')
    WENV_PROJECT='wenv'
    WENV_TASK=''
    WENV_BRANCH='master'
    WENV_GITDIR=''

    wenv_init() { }
    wenv_shutdown() { }
}

wenv() {
    local wenv_command="$1"
    shift
    case "$wenv_command" in
        start)
            wenv_start $@
            ;;
        stop)
            wenv_stop $@
            ;;
        reset)
            wenv_reset $@
            ;;
        task)
            wenv_tasks $@
            ;;
        'cd')
            wenv_cd $@
            ;;
        new)
            wenv_new $@
            ;;
        edit)
            wenv_edit $@
            ;;
        rm|remove)
            wenv_remove $@
            ;;
        'source')
            wenv_source $@
            ;;
        exec)
            wenv_exec $@
            ;;
        mv|rename)
            wenv_rename $@
            ;;
        *)
            echo "Unrecognized command: '$wenv_command'"
            ;;
    esac
}

wenv_start() {
    local flag_n=0
    local flag_q=0
    local flag_i=1
    while getopts ":nqi" opt; do
        case $opt in
            n) flag_n=1 ;;
            q) flag_q=1 ;;
            i) flag_i=0 ;;
        esac
    done
    shift $((OPTIND-1))

    if [[ $# == 0 || ! -f "$WENVS/$1" ]]; then
        return 1
    fi
    local wenv="$1"

    if [[ $flag_n -eq 1 ]]; then
        wenv_stop
        wenv_exec $@ || return 1
        ((flag_i == 1)) && wenv_init
        unset_quiet -f wenv_init
        [[ -n "$DISPLAY" ]] && precmd() {} && echo -ne "\033]0;$USER@$(hostname) #$wenv\007"
        ((flag_q == 1)) || wenv task show
        return 0
    fi

    tmux new-session -d -s "$wenv"
    tmux send -t "$wenv" '{
        wenv_exec '"$@"' || return 1
        tmux set-environment WENV "$WENV"
        (('"$flag_i"' == 1)) && wenv_init
        unset_quiet -f wenv_init
        clear
        (('"$flag_q"' == 1)) || wenv task show
    }' ENTER

    tmux attach-session -t "$wenv"
}

wenv_exec() {
    local flag_c=1
    while getopts ":c" opt; do
        case $opt in
            c) flag_c=0 ;;
        esac
    done
    shift $((OPTIND-1))

    [[ -z "$1" ]] && return 1
    export WENV="$1"

    wenv_load || return 1

    export PS1="($WENV) $ORIGINAL_PS1"

    [[ -n "$WENV_TASK" ]] && task start "$WENV_TASK" >/dev/null 2>&1

    ((flag_c == 1)) && cd "$WENV_DIR" &> /dev/null

    # if [[ $flag_c -eq 1 ]]; then
    #     if [[ -n "$WENV_GIT_DIR" ]]; then
    #         # cd into git repo base dir if available. this option is available to
    #         # avoid trying to cd into a dir that's only in the WENV's branch of
    #         # the repo (which will fail if we're not in the branch)
    #         cd "$WENV_GIT_DIR" &> /dev/null
    #     else
    #         cd "$WENV_DIR" &> /dev/null
    #     fi
    #     if [[ -n "$WENV_BRANCH" ]]; then
    #         local current_branch=$(git branch | grep '*' | sed 's/* //')
    #         if [[ ! -z "$current_branch" && "$WENV_BRANCH" != "$current_branch" ]]; then
    #             git diff-index --quiet HEAD -- 2>/dev/null
    #             # more scalable solution to the below line? don't want to just say -ne 1 because other errors may matter.
    #             # also, checking for value in zsh array is ugly
    #             [[ $? -ne 0 ]] && [[ $? -ne 128 ]] && { warn_uncommitted_changes "$WENV_BRANCH" ; wenv_clean_up ; return 1 }
    #         fi
    #         git checkout "$WENV_BRANCH"
    #     fi
    #     # if we previously cd'd into git repo dir, go to project dir now
    #     [[ -n "$WENV_GIT_DIR" ]] && cd "$WENV_DIR" &> /dev/null
    # fi

    return 0
}

warn_uncommitted_changes() {
    [[ -z "$1" ]] && return 1
    local branch="$1"
    echo "Error: Uncommitted changes, cannot switch to branch $branch. Please clean up and try again."
}

wenv_stop() {
    [[ -z "$WENV" ]] && return 1

    local flag_f=0
    local flag_s=1
    while getopts ":fe" opt; do
        case $opt in
            # force stop, regardless of git working tree state
            f) flag_f=0 ;;
            e) flag_s=0 ;;
        esac
    done
    shift $((OPTIND-1))

    # make sure we're in a git repo and the force flag isn't set
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1 && [[ $flag_f -ne 1 ]]; then
        git diff-index --quiet HEAD -- 2>/dev/null
        [[ $? -ne 0 ]] && [[ $? -ne 128 ]] && { echo "Error: Dirty working tree. Please clean up and try again." ; return 1 }
    fi

    wenv_cd

    [[ -n "$WENV_TASK" ]] && task "$WENV_TASK" stop

    # disabling this for now
    #if [[ -n "$WENV_BRANCH" ]]; then
        #git commit -am "$WENV_BRANCH: rebase me"
        #if [[ `git log -2 | grep "$WENV_BRANCH: rebase me" | wc -l` == '2' ]]; then
            #git reset --soft HEAD~2
            #git commit -am "$WENV_BRANCH: rebase me"
        #fi
        #git checkout master
    #fi

    ((flag_s == 1)) && wenv_shutdown &> /dev/null # TODO: decide when is best to run this
    wenv_clean_up
}

wenv_clean_up() {
    [[ -z "$WENV" ]] && return 1
    unset_quiet -f wenv_{init,shutdown}

    unset_quiet WENV
    unset_quiet WENV_{DIR,DEPS,PROJECT,BRANCH}

    if [[ -n "$TMUX" ]]; then
        tmux set-environment WENV ''
        tmux rename-session $(tmux display-message -p '#{session_id}' | tr -d '$')
    else
        # load the old precmd (TODO: better way to do this?)
        [[ -n "$DISPLAY" ]] && set_default_window_name
    fi
    export PS1="$ORIGINAL_PS1"
}

wenv_cd() {
    local flag_r=0
    while getopts ":r" opt; do
        case $opt in
            r) flag_r=1 ;;
            --) break ;;
            *) echo "invalid flag: $1" ; exit 1 ;;
        esac
    done
    shift $((OPTIND-1))

    if [[ -z "$1" ]]; then
        [[ ! -z "$WENV_DIR" ]] && cd "$WENV_DIR" &> /dev/null
        return 0
    fi
    if ! is_wenv "$1"; then
        return 1
    fi
    local wenv="$1"

    ((flag_r == 1)) && tmux rename-window "$wenv"

    # TODO: need a better way to do this
    # load and cd to input wenv
    wenv_load "$wenv"
    cd "$WENV_DIR"

    # reload the wenv that was previously running
    wenv_load "$WENV"
    unset_quiet -f wenv_init

    return 0
}

# load either the input wenv, or the active WENV + its dependencies
wenv_load() {
    if [[ -n "$1" ]]; then
        local wenv="$1"
        run_wenv_setup "$wenv"
        wenv_source "$wenv"
    elif [[ -n "$WENV" ]]; then
        run_wenv_setup "$WENV"
        wenv_setup
        wenv_source
    else
        return 1
    fi
    unset -f wenv_setup
}

run_wenv_setup() {
    [[ -z "$1" ]] && return 1
    local wenv="$1"
    eval "$(source $WENVS/$wenv && declare -f wenv_setup)"
    declare -f wenv_setup >/dev/null || return 1
    wenv_setup
}

wenv_new() {
    local src="$SRC/wenv/wenv_template"
    local flag_d=0
    while getopts ":di:" opt; do
        case $opt in
            d) flag_d=1 ;;
            i) [[ ! -z "$OPTARG" ]] && src="$WENVS/${OPTARG}" ;;
            --) break ;;
            *) echo "invalid flag: $1" ; exit 1 ;;
        esac
    done
    shift $((OPTIND-1))

    [[ -z "$1" ]] && return 1
    local wenv="$1"

    # generalize/clean this up
    if [[ $flag_d -eq 1 ]]; then
        cat =(sed -r "s@WENV_DIR=.*?@WENV_DIR=\"`pwd`\"@" "$src") > "$WENVS/${wenv}"
    else
        # this case shouldn't be exclusive from previous
        cp "$src" "$WENVS/${wenv}"
    fi
    wenv_edit "$wenv"
}

wenv_edit() {
    # nice bash syntax for setting var to first non-empty variable
    local wenv="${1:-${WENV}}"
    [[ -f "$WENVS/$wenv" ]] && "$EDITOR" "$WENVS/$wenv"
}

wenv_remove() {
    if [[ -z "$1" ]]; then
        return 1
    fi
    if ! is_wenv "$1"; then
        echo "WENV $1 does not exist."
        return 1
    fi
    local wenv="$1"
    local wenv_file="$WENVS/${wenv}"
    read "choice?Delete WENV $wenv? "
    if [[ "$choice" =~ ^[Yy]$ ]]; then
        rm -f "$wenv_file"
    fi
}

wenv_reset() {
    [[ -n "TMUX" ]] && tmux set-environment WENV "$WENV"
}

wenv_tasks() {
    local arg="$1"
    shift 2> /dev/null
    case "$arg" in
        s|show)
            wenv_tasks_show $@
            ;;
        a|add)
            wenv_tasks_add $@
            ;;
        *)
            wenv_tasks_show "$arg" $@
            ;;
    esac
}

wenv_tasks_show() {
    local wenv="${WENV_PROJECT:-${WENV}}"
    [[ -z "$wenv" ]] && return 1
    local flag_w=0
    while getopts ":w:" opt; do
        case $opt in
            w)  [[ ! -z "$OPTARG" ]] && wenv="$OPTARG" ;;
            --) break ;;
            *)  echo "invalid flag: $1" ; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    local report="$1"
    [[ -z "$report" ]] && report="project"

    echo "$wenv"
    task "$report" project:"$wenv"
}

wenv_tasks_add() {
    [[ -z "$@" ]] && return 1
    local wenv="${WENV_PROJECT:-${WENV}}"
    local flag_w=0
    while getopts ":w:" opt; do
        case $opt in
            w)  [[ ! -z "$OPTARG" ]] && local wenv="$OPTARG" ;;
            --) break ;;
            *)  echo "invalid flag: $1" ; return 1 ;;
        esac
    done
    shift $((OPTIND-1))

    # last passed argument is description (usually quoted string)
    local desc="${@[$#]}"
    # all other args are passed to task warrior (yeah, this is ugly)
    local task_args=${@:1:$(($# - 1))}
    task add project:"$wenv" tags:"$WENV" "$task_args" -- "$desc"
}

wenv_source() {
    if [[ "$#" -eq 0 && -n "$WENV" ]]; then
        (( ${#WENV_DEPS[@]} != 0 )) && wenv_source "${WENV_DEPS[@]}"
        source "$WENVS/$WENV" >/dev/null
    fi
    local wenv
    for wenv in $@; do
        source "$WENVS/$wenv" >/dev/null
    done
}

wenv_rename() {
    [[ $# != 2 ]] && return 1
    local old="$1"
    local new="$2"

    mv "$WENVS/$old" "$WENVS/$new"
}

wenv_tmux_layout() {
    local layout="$1"
    shift
    case "$layout" in
        dev)
            wenv_tmux_split v
            tmux resize-pane -y 7
            [[ -n "$@" ]] && tmux send-keys "$*" 'Enter'
            tmux select-pane -U
            ;;
        devloop)
            local watch='git'
            [[ "$1" == '-w' ]] && watch="$2" && shift 2
            wenv_tmux_layout 'dev' "monitor $watch $*"
            ;;
        dev-tasks)
            local watch='git'
            [[ "$1" == '-w' ]] && watch="$2" && shift 2
            wenv_tmux_split v
            tmux resize-pane -y 7
            [[ -n "$@" ]] && tmux send-keys "monitor $watch $@" 'Enter'
            wenv_tmux_split h
            tmux send-keys 'wenv task show' 'Enter'
            tmux select-pane -L
            tmux select-pane -U
            ;;
        tasks)
            wenv_tmux_split v
            tmux resize-pane -y 7
            tmux send-keys 'wenv task show' 'Enter'
            tmux select-pane -U
            ;;
        split-tasks)
            wenv_tmux_layout tasks
            wenv_tmux_split h
            [[ -n "$@" ]] && tmux send-keys "$@" 'Enter'
            tmux select-pane -L
            ;;
        *)
            return 1
            ;;
    esac
}

wenv_tmux_split() {
    while getopts ":n:" opt; do
        case $opt in
            n) [[ ! -z "$OPTARG" ]] && local name="$OPTARG" ;;
            *) echo "invalid flag: $opt" ; exit 1 ;;
        esac
    done
    shift $((OPTIND-1))

    local wenv_init_cmd='ZSH_INIT="unset WENV; wenv exec -c \"$WENV\"" zsh -i'
    local direction="$1"
    shift
    local user_cmd=$@
    case "$direction" in
        h|horizontal)
            split_args=('split-window' '-h')
            ;;
        v|vertical)
            split_args=('split-window')
            ;;
        c|window)
            split_args=('new-window')
            [[ -n "$name" ]] && split_args+=('-n' "$name")
            ;;
        *)
            return 1
            ;;
    esac
    tmux $split_args -c "#{pane_current_path}" "$wenv_init_cmd"
    tmux send-keys "$user_cmd" 'Enter'
}

is_wenv() {
    if [[ -z "$1" ]]; then
        return 1
    fi
    local wenv_file="$WENVS/$1"
    if [[ ! -f "$wenv_file" ]]; then
        return 1
    fi
    return 0
}

unset_quiet() {
    unset $@ &>/dev/null
}
